#include "Ast.h"
#include "SymbolTable.h"
#include "Unit.h"
#include "Instruction.h"
#include "IRBuilder.h"
#include <string>
#include "Type.h"

std::vector<Type *> functype;
std::vector<bool> getret;
std::vector<bool> inwhile;
std::map<std::string,std::vector<std::vector<Type*>>> function; 
int funcdeftimes=0,arraytemp=0;
std::vector<std::string> fname;
std::vector<std::string> aname;
std::vector<std::vector<Type*>> rparam;
bool misreturn,chforFPorLV;
std::map<std::string,int> arraydef;
std::vector<Operand*> operands;
std::vector<std::vector<Operand*>> Rparamop;
bool createbr;
std::vector<Operand*> tempOp;

extern FILE *yyout;
int Node::counter = 0;
IRBuilder* Node::builder = nullptr;

Node::Node()
{
    seq = counter++;
}

void Node::backPatchTrue(std::vector<Instruction*> &list, BasicBlock*bb)
{
    for(auto &inst:list)
    {
        if(inst->isCond())
            dynamic_cast<CondBrInstruction*>(inst)->setTrueBranch(bb);
        else if(inst->isUncond())
            dynamic_cast<UncondBrInstruction*>(inst)->setBranch(bb);
    }
}

void Node::backPatchFalse(std::vector<Instruction*> &list, BasicBlock*bb)
{
    for(auto &inst:list)
    {
        if(inst->isCond())
            dynamic_cast<CondBrInstruction*>(inst)->setFalseBranch(bb);
        else if(inst->isUncond())
            dynamic_cast<UncondBrInstruction*>(inst)->setBranch(bb);
    }
}

std::vector<Instruction*> Node::merge(std::vector<Instruction*> &list1, std::vector<Instruction*> &list2)
{
    std::vector<Instruction*> res(list1);
    res.insert(res.end(), list2.begin(), list2.end());
    return res;
}

void Ast::genCode(Unit *unit)
{
    IRBuilder *builder = new IRBuilder(unit);
    Node::setIRBuilder(builder);
    root->genCode();
}

void FunctionDef::genCode()
{
    Unit *unit = builder->getUnit();
    Function *func = new Function(unit, se);
    BasicBlock *entry = func->getEntry();
    // set the insert point to the entry basicblock of this function.
    builder->setInsertBB(entry);
    if(param!=nullptr)
    {
        param->genCode();
    }
    stmt->genCode();
    func->setParams(myoperands);
    /**
     * Construct control flow graph. You need do set successors and predecessors for each basic block.
     * Todo
    */

}

void FuncFParam::genCode()
{
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    Function *func = builder->getInsertBB()->getParent();
    BasicBlock *entry = func->getEntry();
    Instruction *alloca;
    Operand *addr;
    SymbolEntry *addr_se;
    Type *type;
    Operand* dst = se->getAddr();
    type = new PointerType(se->getType());
    addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
    addr = new Operand(addr_se);
    alloca = new AllocaInstruction(addr, se);                   // allocate space for local id in function stack.
    new StoreInstruction(addr,dst,entry);
    entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
    se->setAddr(addr);
    //array still not be implemented 
}

void FuncFParams::genCode()
{
    funcFParams->genCode();
    funcFParam->genCode();
}

void BinaryExpr::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    Function *func = bb->getParent();
    dst = new Operand(symbolEntry);
    fprintf(stderr,"type : %s\n",symbolEntry->getType()->toStr().c_str());
    if (op == AND)
    {
        BasicBlock *trueBB = new BasicBlock(func);  // if the result of lhs is true, jump to the trueBB.
        createbr = true;
        expr1->genCode();
        backPatchTrue(expr1->trueList(), trueBB);
        bb->addSucc(trueBB);
        trueBB->addPred(bb);
        builder->setInsertBB(trueBB);               // set the insert point to the trueBB so that intructions generated by expr2 will be inserted into it.
        createbr = true;
        expr2->genCode();
        true_list = expr2->trueList();
        false_list = merge(expr1->falseList(), expr2->falseList());
    }
    else if(op == OR)
    {
        // Todo
        BasicBlock *falseBB = new BasicBlock(func);// if the result of  is false ,jump to the falseBB
        createbr = true;
        expr1->genCode();
        backPatchFalse(expr1->falseList(), falseBB);
        bb->addSucc(falseBB);
        falseBB->addPred(bb);
        builder->setInsertBB(falseBB);
        createbr = true;
        expr2->genCode();
        true_list = merge(expr1->trueList(),expr2->trueList());
        false_list = expr2->falseList();
    }
    else if(op >= LESS && op <= EQUAL)
    {
        // Todo
        bool crbrnow = createbr;
        createbr = false;
        expr1->genCode();
        createbr = false;
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch(op)
        {
        case LESS:
            opcode = CmpInstruction::L;
            break;
        case MORE:
            opcode = CmpInstruction::G;
            break;
        case LESSEQU:
            opcode = CmpInstruction::LE;
            break;
        case MOREEQU:
            opcode = CmpInstruction::GE;
            break;
        case NOTEQUAL:
            opcode = CmpInstruction::NE;
            break;
        case EQUAL:
            opcode = CmpInstruction::E;
            break;
        }
        new CmpInstruction(opcode,dst,src1,src2,bb);
        if(crbrnow){
            Instruction* br = new CondBrInstruction(nullptr,nullptr,dst,bb);
            true_list.push_back(br);
            false_list.push_back(br);
        }
        
    }
    else if(op >= ADD && op <= MOD)
    {
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        Operand* src1e = new Operand(new TemporarySymbolEntry(TypeSystem::intType,SymbolTable::getLabel())) 
        ,*src2e = new Operand(new TemporarySymbolEntry(TypeSystem::intType,SymbolTable::getLabel())) ;
        
        int opcode;
        switch (op)
        {
        case ADD:
            opcode = BinaryInstruction::ADD;
            break;
        case SUB:
            opcode = BinaryInstruction::SUB;
            break;
        case MUL:
            opcode = BinaryInstruction::MUL;
            break;
        case DIV:
            opcode = BinaryInstruction::DIV;
            break;
        case MOD:
            opcode = BinaryInstruction::MOD;
            break;
        }
        
        if(!src1->getType()->isI32())
        {
            new ExtInstruction(src1e,src1,bb);
            src1 = src1e;
        }
        if(!src2->getType()->isI32())
        {
            fprintf(stderr,"src2 extend\n");
            new ExtInstruction(src2e,src2,bb);
            src2 = src2e;
        }
        new BinaryInstruction(opcode, dst, src1, src2, bb);
    }
}

void UnaryExpr::genCode()
{
    BasicBlock* bb = builder->getInsertBB();
    if(op == NOT )
    {
        expr->genCode();
        true_list = expr->falseList();
        false_list = expr->trueList();
        if(expr->getSymPtr()->getType()==TypeSystem::intType)
        {
            Operand* src1 = expr->getOperand();
            Operand* src2 = new Operand(new ConstantSymbolEntry(TypeSystem::intType,0));
            Operand* cmp_dst = new Operand(new TemporarySymbolEntry(TypeSystem::boolType,SymbolTable::getLabel()));
            new CmpInstruction(CmpInstruction::NE, cmp_dst, src1, src2, bb);
            Operand* c1 = new Operand(new ConstantSymbolEntry(TypeSystem::boolType,1));
            new BinaryInstruction(BinaryInstruction::XOR, dst, cmp_dst, c1, bb);
        }
        else if(expr->getSymPtr()->getType()==TypeSystem::boolType)
        {
            Operand* src1 = expr->getOperand();
            Operand* c1 = new Operand(new ConstantSymbolEntry(TypeSystem::boolType,1));
            new BinaryInstruction(BinaryInstruction::XOR, dst, src1, c1, bb);
        }
    }
    else if(op >= ADD && op <= SUB)
    {
        expr->genCode();
        Operand *src = expr->getOperand();
        int opcode;
        true_list = expr->trueList();
        false_list = expr->falseList();
        Operand* srce = new Operand(new TemporarySymbolEntry(TypeSystem::intType,SymbolTable::getLabel())) ;
        switch (op)
        {
        case ADD:
            opcode = UnaryInstruction::ADD;
            break;
        case SUB:
            opcode = UnaryInstruction::SUB;
            break;
        }
         if(!src->getType()->isI32())
        {
            new ExtInstruction(srce,src,bb);
            src = srce;
        }
        
        new UnaryInstruction(opcode, dst, src, bb);
    }
}

void Constant::genCode()
{
    // we don't need to generate code.
}

void BracketList::genCode()
{

}

void Bracket::genCode()
{

}

void InitValList::genCode()
{

}

void InitVal::genCode()
{

}

void Id::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getAddr();
    new LoadInstruction(dst, addr, bb);
}

void FuncRParam::genCode()
{
    expr->genCode();
    operands.push_back(expr->getOperand());
}


void FuncRParams::genCode()
{
    funcRParam->genCode();
    funcRParams->genCode();
}

void FuncCallExpr::genCode()
{
    BasicBlock *bb = builder->getInsertBB();

    if(funcRParams!=nullptr)
    {
        operands.clear();
        funcRParams->genCode();
    }
    // SymbolEntry* se = id->getSymPtr();
    // dynamic_cast<FuncFParams* >(funcRParams)->getParams(params);
    new FuncCallInstruction(dst,symbolEntry,operands,bb);
}

void IfStmt::genCode()
{
    //fprintf(stderr,"ifstmt gencode\n");
    Function *func;
    BasicBlock *then_bb, *end_bb,*bb;

    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
    bb=builder->getInsertBB();
    bb->addSucc(then_bb);
    then_bb->addPred(bb);
    bb->addSucc(end_bb);
    end_bb->addPred(bb);
    then_bb->addSucc(end_bb);
    end_bb->addPred(then_bb);

    //fprintf(stderr,"cond gencode\n");
    createbr = true;
    cond->genCode();
    createbr = false;
    //fprintf(stderr,"cond gencode done\n");

    backPatchTrue(cond->trueList(), then_bb);
    backPatchFalse(cond->falseList(), end_bb);
    
    builder->setInsertBB(then_bb);
    //fprintf(stderr,"then gencode\n");
    thenStmt->genCode();
    //fprintf(stderr,"then gencode done\n");
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(end_bb);
    //fprintf(stderr,"ifstmt gencode done\n");
}

void IfElseStmt::genCode()
{
    // Todo
    Function *func;
    BasicBlock *then_bb,*else_bb,*end_bb,*bb;
    bb=builder->getInsertBB();
    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    else_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);

    bb->addSucc(then_bb);
    then_bb->addPred(bb);
    bb->addSucc(else_bb);
    else_bb->addPred(bb);
    then_bb->addSucc(end_bb);
    end_bb->addPred(then_bb);
    else_bb->addSucc(end_bb);
    end_bb->addPred(else_bb);

    createbr = true;
    cond->genCode();
    createbr = false;

    backPatchTrue(cond->trueList(), then_bb);
    backPatchFalse(cond->falseList(), else_bb);

    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    then_bb=builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(else_bb);
    elseStmt->genCode();
    else_bb=builder->getInsertBB();
    new UncondBrInstruction(end_bb, else_bb);

    builder->setInsertBB(end_bb);
}

void CompoundStmt::genCode()
{
    // Todo
    if(stmt!=nullptr){
        stmt->genCode();
    }
}

void SeqNode::genCode()
{
    // Todo
    stmt1->genCode();
    stmt2->genCode();
}

void ExprStmt::genCode()
{
    expr->genCode();
}
//DeclStmt and DefStmt
void DefStmt::genCode()
{
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    if(se->isGlobal())
    {
        Unit* u=builder->getUnit();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        alloca = new GlobalAllocaInstruction(addr, se);
        u->insertGlobal(alloca);    
        se->setAddr(addr);
    }
    else if(se->isLocal())
    {
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se);                   // allocate space for local id in function stack.
        entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
        se->setAddr(addr);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.
    }
}

void DefStmtList::genCode()
{
    def1->genCode();
    def2->genCode();
}

void DeclStmt::genCode()
{
    defList->genCode();
}

void DefAssignStmt::genCode()
{
    // new AllocInstruction and storeInstruction
    BasicBlock *bb = builder->getInsertBB();

    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    if(se->isGlobal())
    {
        Unit* u=builder->getUnit();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);  
        se->setAddr(addr);
        expr->genCode();
        alloca = new GlobalAllocaInstruction(addr, se,expr->getSymPtr()->toStr());
        u->insertGlobal(alloca);  
    }
    else if(se->isLocal())
    {
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se);                   // allocate space for local id in function stack.
        entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
        se->setAddr(addr);
        expr->genCode();
        addr = dynamic_cast<IdentifierSymbolEntry*>(id->getSymPtr())->getAddr();
        Operand *src = expr->getOperand();
        new StoreInstruction(addr, src, bb);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.
    }

    
}

void ArrayDefAssignStmt::genCode()
{

}

void ArrayDefStmt::genCode()
{

}

void WhileStmt::genCode()
{
    BasicBlock* bb=builder->getInsertBB();
    Function* func = bb->getParent();
    BasicBlock  *cond_bb, *end_bb, *loop_bb;
    loop_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
    cond_bb = new BasicBlock(func);
    new UncondBrInstruction(cond_bb,bb);
//succ and pred
    bb->addSucc(cond_bb);
    cond_bb->addPred(bb);
    cond_bb->addSucc(loop_bb);
    loop_bb->addPred(cond_bb);
    loop_bb->addSucc(cond_bb);
    cond_bb->addPred(loop_bb);
    cond_bb->addSucc(end_bb);
    end_bb->addPred(cond_bb);

    builder->setInsertBB(cond_bb);//continue

    createbr = true;
    cond->genCode();
    createbr = false;

    backPatchTrue(cond->trueList(),loop_bb);
    backPatchFalse(cond->falseList(),end_bb);

    builder->setInsertBB(loop_bb);
    whileStmt->genCode();
    loop_bb = builder->getInsertBB();
    new UncondBrInstruction(cond_bb, loop_bb);

    builder->setInsertBB(end_bb);
}

void ReturnStmt_noExp::genCode()
{
    BasicBlock* bb = builder->getInsertBB();
    new RetInstruction(nullptr,bb);
}

void ReturnStmt::genCode()
{
    // Todo
    BasicBlock* bb=builder->getInsertBB();
    retValue->genCode();
    Operand* retv = retValue->getOperand();
    new RetInstruction(retv,bb);
}

void ContinueStmt::genCode()
{

}

void BreakStmt::genCode()
{

}

void EmptyStmt::genCode()
{

}

void AssignStmt::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    expr->genCode();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(lval->getSymPtr())->getAddr();
    Operand *src = expr->getOperand();
    /***
     * We haven't implemented array yet, the lval can only be ID. So we just store the result of the `expr` to the addr of the id.
     * If you want to implement array, you have to caculate the address first and then store the result into it.
     */
    new StoreInstruction(addr, src, bb);
}

void Ast::typeCheck()
{
    // fprintf(stderr, "root\n");
    std::string name ;
    std::vector<Type*> v;

    name = std::string("getint");
    v.push_back(TypeSystem::intType);
    function[name].push_back(v);
    v.clear();

    name = std::string("getch");
    v.push_back(TypeSystem::intType);
    function[name].push_back(v);
    v.clear();

    name = std::string("getarray");
    v.push_back(TypeSystem::intType);
    v.push_back(TypeSystem::constType);
    function[name].push_back(v);
    v.clear();


    name = std::string("putarray");
    v.push_back(TypeSystem::voidType);
    v.push_back(TypeSystem::intType);
    v.push_back(TypeSystem::arrayType);
    function[name].push_back(v);
    v.clear();

    name = std::string("putint");
    v.push_back(TypeSystem::voidType);
    v.push_back(TypeSystem::intType);
    function[name].push_back(v);
    v.clear();

    name = std::string("putch");
    v.push_back(TypeSystem::voidType);
    v.push_back(TypeSystem::intType);
    function[name].push_back(v);
    v.clear();

    name = std::string("putf");
    v.push_back(TypeSystem::voidType);
    v.push_back(TypeSystem::intType);
    function[name].push_back(v);
    v.clear();

    if(root != nullptr)
        root->typeCheck();
}

void Extend::genCode() 
{
    expr->genCode();
    BasicBlock *bb = builder->getInsertBB();
    new ExtInstruction(dst, expr->getOperand(), bb);
}

void BinaryExpr::typeCheck()
{
    // Todo
    // fprintf(stderr, "binary\n");
    expr1->typeCheck();
    expr2->typeCheck();
    // fprintf(stderr, "binary\n");
    Type* type1,* type2;
    type1 = expr1->getSymPtr()->getType();
    type2 = expr2->getSymPtr()->getType();
    if(type1->isFunc()){
        // FuncCallExpr* expr = (FuncCallExpr*) expr1;
        // type1 = expr->getret()->getRetType();
        FunctionType* type = (FunctionType*)type1;
        type1 = type->getRetType();
    }
    if(type2->isFunc()){
        // FuncCallExpr* expr = (FuncCallExpr*) expr2;
        // type2 = expr->getret()->getRetType();
        FunctionType* type = (FunctionType*)type2;
        type2 = type->getRetType();
    }
    if(type1->isArray()){
        Id* expr = (Id*) expr1;
        ArrayType* tempt = (ArrayType *)expr->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        // fprintf(stderr,"temp: %i , dimension: %i\n",temp,di);
        if(temp==di){
            type1 = TypeSystem::intType;
        }else if(temp<di){
            type1 = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    if(type2->isArray()){
        Id* expr = (Id*) expr2;
        ArrayType* tempt = (ArrayType *)expr->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        if(temp==di){
            type2 = TypeSystem::intType;
        }else if(temp<di){
            type2 = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    // fprintf(stderr,"type2 : %s \n",type2->toStr().c_str());
    // fprintf(stderr,"type1 : %s , type2 : %s \n",type1->toStr().c_str(),type2->toStr().c_str());
    if(!(type1->isInt()&&type2->isInt())){
        fprintf(stderr, "type %s and %s mismatch \n",
           type1->toStr().c_str(), type2->toStr().c_str());
        exit(EXIT_FAILURE);
    }
    switch (op)
    {
    case ADD:
        /* code */
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::intType);
        break;
    case SUB:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::intType);
        break;
    case MUL:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::intType);
        break;
    case DIV:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::intType);
        break;
    case MOD:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::intType);
        break;
    case AND:
        if(type1->isI32()){
            SymbolEntry *se = new ConstantSymbolEntry(type1, 0);
            Constant *zero = new Constant(se);
            expr1 = new BinaryExpr(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()), BinaryExpr::NOTEQUAL, expr1, zero);
        }
        if(type2->isI32()){
            SymbolEntry *se = new ConstantSymbolEntry(type2, 0);
            Constant *zero = new Constant(se);
            expr2 = new BinaryExpr(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()), BinaryExpr::NOTEQUAL, expr2, zero);
        }
        symbolEntry->setType(TypeSystem::boolType);
        break;
    case OR:
        if(type1->isI32()){
            SymbolEntry *se = new ConstantSymbolEntry(type1, 0);
            Constant *zero = new Constant(se);
            expr1 = new BinaryExpr(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()), BinaryExpr::NOTEQUAL, expr1, zero);
        }
        if(type2->isI32()){
            SymbolEntry *se = new ConstantSymbolEntry(type2, 0);
            Constant *zero = new Constant(se);
            expr2 = new BinaryExpr(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()), BinaryExpr::NOTEQUAL, expr2, zero);
        }
        symbolEntry->setType(TypeSystem::boolType);    
        break;
    case LESS:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::boolType);
        break;
    case MORE:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::boolType);
        break;
    case LESSEQU:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::boolType);
        break;
    case MOREEQU:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::boolType);
        break;
    case NOTEQUAL:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::boolType);
        break;
    case EQUAL:
        if(!type1->isI32()){
            expr1 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr1);
        }
        if(!type2->isI32()){
            expr2 = new Extend(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()), expr2);
        }
        symbolEntry->setType(TypeSystem::boolType);
        break;
    default:
        break;
    }
}

void UnaryExpr::typeCheck()
{
    // Todo
    // fprintf(stderr, "unary\n");
    expr->typeCheck();
    Type* type1;
    type1 = expr->getSymPtr()->getType();
    if(type1->isFunc()){
        FunctionType* type = (FunctionType*)type1;
        type1 = type->getRetType();
    }
    
    if(type1->isVoid()){
        fprintf(stderr, "function return type is void");
        exit(EXIT_FAILURE);
    }
    switch (op)
    {
    case /* constant-expression */ADD:
        /* code */
        symbolEntry->setType(TypeSystem::intType);
        break;
    case /* constant-expression */SUB:
        /* code */
        symbolEntry->setType(TypeSystem::intType);
        break;
    case /* constant-expression */NOT:
        /* code */
        symbolEntry->setType(TypeSystem::boolType);
        break;
    default:
        break;
    }
}

void Constant::typeCheck()
{
    // Todo
}

void BracketList::typeCheck()
{
    // Todo
    bracket->typeCheck();
    bracketList->typeCheck();
}

void Bracket::typeCheck()
{
    // Todo
    // fprintf(stderr,"bracket\n");
    if(chforFPorLV){
        arraytemp++;
    }else{
        arraydef[aname.back()]++;
    }
    if(expr!=nullptr){
        expr->typeCheck();
    }
}

void InitValList::typeCheck()
{
    // Todo
    initVal->typeCheck();
    initValList->typeCheck();
}

void InitVal::typeCheck()
{
    // Todo
    expr->typeCheck();
}

void Id::typeCheck()
{
    // Todo
    if(symbolEntry->getType()->isArray()){
        arraytemp=0;
        if(bracketList!=nullptr){
            chforFPorLV=true;
            // fprintf(stderr,"Id1\n");
            bracketList->typeCheck();
            chforFPorLV=false;
        }
    }
}

void FuncRParam::typeCheck()
{
    // Todo
    expr->typeCheck();
    Type* type1 = expr->getSymPtr()->getType();
    //expr->getSymPtr()->getType();
    if(type1->isFunc()){
        FunctionType* type = (FunctionType*)type1;
        type1 = type->getRetType();
    }
    if(type1->isArray()){
        Id* expr1 = (Id*) expr;
        expr1->settemp(arraytemp);
        ArrayType* tempt = (ArrayType *)expr1->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        if(temp==di){
            type1 = TypeSystem::intType;
        }else if(temp<di){
            type1 = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    rparam.back().push_back(type1);
    Rparamop.back().push_back(new Operand(expr->getSymPtr()));
    // fprintf(stderr,"push %s %s\n",expr->getSymPtr()->getName().c_str(),type1->toStr().c_str());
    // Type* type2 = funcRParams->getSymPtr()->getType();
    // if(type1->isFunc()){
    //     FunctionType* type = (FunctionType*)type2;
    //     type2 = type->getRetType();
    // }
    // this->getSymPtr()->setType(type2);
}

void FuncRParams::typeCheck()
{
    // Todo
    funcRParam->typeCheck();
    funcRParams->typeCheck();
    
    // Type* type1 = expr->getSymPtr()->getType();
    // if(type1->isFunc()){
    //     FunctionType* type = (FunctionType*)type1;
    //     type1 = type->getRetType();
    // }
    // // fprintf(stderr,"push %s %s\n",expr->getSymPtr()->getName().c_str(),type1->toStr().c_str());
    // rparam.push_back(type1);
    // Type* type2 = funcRParams->getSymPtr()->getType();
    // if(type1->isFunc()){
    //     FunctionType* type = (FunctionType*)type2;
    //     type2 = type->getRetType();
    // }
    // this->getSymPtr()->setType(type2);
}

void FuncCallExpr::typeCheck()
{
    // Todo
    id->typeCheck();
    fname.push_back (id->getSymPtr()->getName());
    // fprintf(stderr,"%s typecheck\n",fname.back().c_str());
    std::vector<Type*> v1;
    std::vector<Operand*> v2;
    rparam.push_back(v1);
    Rparamop.push_back(v2);
    if(funcRParams!=nullptr){
        funcRParams->typeCheck();
    }
    
    bool find;
    int fsize = function[fname.back()].size();
    // fprintf(stderr,"%i\n",fsize);
    if(fsize==0){
        fprintf(stderr,"function %s is undefined\n",fname.back().c_str());
    }
    for(int i=0;i<fsize;i++){
        find=true;
        int size=function[fname.back()][i].size();
        int rparamSize=rparam.back().size();
        if(rparamSize==size-1){
            if(size>1){
                for(int j=1;j<size;j++){
                    if(rparam.back()[j-1]!=function[fname.back()][i][j]){
                        // fprintf(stderr,"%i\n",rparam[j-1]->isFunc());
                        find=false;
                        break;
                    }
                }
            }
            symbolEntry->setType(new FunctionType(function[fname.back()][i].front(),rparam.back()));
            setOperand(Rparamop.back());
            SymbolEntry *temp = new TemporarySymbolEntry(function[fname.back()][i].front(), SymbolTable::getLabel()); 
            dst = new Operand(temp);
            // setret(new FunctionType(function[fname][i].front(),rparam));
            // fprintf(stderr, "type %s\n",getret()->getRetType()->toStr().c_str());
            break;
        }
        else{
            // fprintf(stderr,"2\n");
            find=false;
            continue;
        }
    }
    Rparamop.pop_back();
    rparam.pop_back();
    if(find==false){
        fprintf(stderr,"function %s funcFParam mismatch funcRParam \n",fname.back().c_str());
        exit(EXIT_FAILURE);
    }
    fname.pop_back();
}

void IfStmt::typeCheck()
{
    // Todo
    cond->typeCheck();
    Type* type = cond->getSymPtr()->getType();
    if(type->isFunc()){
        // FuncCallExpr* expr = (FuncCallExpr*) expr2;
        // type2 = expr->getret()->getRetType();
        FunctionType* type1 = (FunctionType*)type;
        type = type1->getRetType();
    }
    if(type->isArray()){
        Id* expr = (Id*) cond;
        ArrayType* tempt = (ArrayType *)expr->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        // fprintf(stderr,"temp: %i , dimension: %i\n",temp,di);
        if(temp==di){
            type = TypeSystem::intType;
        }else if(temp<di){
            type = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    if(type->isI32()){
        SymbolEntry *se = new ConstantSymbolEntry(type, 0);
        Constant *zero = new Constant(se);
        cond = new BinaryExpr(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()), BinaryExpr::NOTEQUAL, cond, zero);
    }
    thenStmt->typeCheck();
}

void IfElseStmt::typeCheck()
{
    // Todo
    cond->typeCheck();
    Type* type = cond->getSymPtr()->getType();
    if(type->isFunc()){
        // FuncCallExpr* expr = (FuncCallExpr*) expr2;
        // type2 = expr->getret()->getRetType();
        FunctionType* type1 = (FunctionType*)type;
        type = type1->getRetType();
    }
    if(type->isArray()){
        Id* expr = (Id*) cond;
        ArrayType* tempt = (ArrayType *)expr->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        // fprintf(stderr,"temp: %i , dimension: %i\n",temp,di);
        if(temp==di){
            type = TypeSystem::intType;
        }else if(temp<di){
            type = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    if(type->isI32()){
        SymbolEntry *se = new ConstantSymbolEntry(type, 0);
        Constant *zero = new Constant(se);
        cond = new BinaryExpr(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()), BinaryExpr::NOTEQUAL, cond, zero);
    }
    thenStmt->typeCheck();
    elseStmt->typeCheck();
    
}

void ReturnStmt_noExp::typeCheck()
{
    // Todo
    Type* type = TypeSystem::voidType;
    if(!functype.empty()&&functype.back()!=type){
        fprintf(stderr, "return type require %s not %s \n"
            ,functype.back()->toStr().c_str(),type->toStr().c_str());
        exit(EXIT_FAILURE);
    }
    if(!getret.empty()){
        getret.back()=true;
    }
}

void ReturnStmt::typeCheck()
{
    // Todo
    // fprintf(stderr,"return\n");
    retValue->typeCheck();
    Type* type = retValue->getSymPtr()->getType();
    if(type->isFunc()){
        FunctionType* type1 = (FunctionType*)type;
        type = type1->getRetType();
    }
    if(type->isArray()){
        Id* expr = (Id*) retValue;
        ArrayType* tempt = (ArrayType *)expr->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        // fprintf(stderr,"temp: %i , dimension: %i\n",temp,di);
        if(temp==di){
            type = TypeSystem::intType;
        }else if(temp<di){
            type = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    if(!functype.empty()&&functype.back()!=type){
        fprintf(stderr, "return type require %s not %s \n"
            ,functype.back()->toStr().c_str(),type->toStr().c_str());
        exit(EXIT_FAILURE);
    }
    if(!getret.empty()){
        getret.back()=true;
    }
}


void ContinueStmt::typeCheck()
{
    // Todo
    if(inwhile.empty()){
        fprintf(stderr, "continueStmt should be in whileStmt\n");
        exit(EXIT_FAILURE);
    }
}

void BreakStmt::typeCheck()
{
    // Todo
    if(inwhile.empty()){
        fprintf(stderr, "breakStmt should be in whileStmt\n");
        exit(EXIT_FAILURE);
    }
}

void EmptyStmt::typeCheck()
{
    // Todo
}

void WhileStmt::typeCheck()
{
    // Todo
    inwhile.push_back(true);
    cond->typeCheck();
    Type* type = cond->getSymPtr()->getType();
    if(type->isFunc()){
        // FuncCallExpr* expr = (FuncCallExpr*) expr2;
        // type2 = expr->getret()->getRetType();
        FunctionType* type1 = (FunctionType*)type;
        type = type1->getRetType();
    }
    if(type->isArray()){
        Id* expr = (Id*) cond;
        ArrayType* tempt = (ArrayType *)expr->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        // fprintf(stderr,"temp: %i , dimension: %i\n",temp,di);
        if(temp==di){
            type = TypeSystem::intType;
        }else if(temp<di){
            type = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    if(type->isI32()){
        SymbolEntry *se = new ConstantSymbolEntry(type, 0);
        Constant *zero = new Constant(se);
        cond = new BinaryExpr(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()), BinaryExpr::NOTEQUAL, cond, zero);
    }
    whileStmt->typeCheck();
    inwhile.pop_back();
}

void CompoundStmt::typeCheck()
{
    // Todo
    if(stmt!=nullptr){
        stmt->typeCheck();
    }
}

void SeqNode::typeCheck()
{
    // Todo
    // fprintf(stderr, "seqnode\n");
    stmt1->typeCheck();
    stmt2->typeCheck();
}

void ExprStmt::typeCheck()
{
    // Todo
    expr->typeCheck();
}

void DefStmt::typeCheck()
{
    // Todo
    id->typeCheck();
}

void DefStmtList::typeCheck()
{
    // Todo
    def1->typeCheck();
    def2->typeCheck();
}

void DefAssignStmt::typeCheck()
{
    // Todo
    id->typeCheck();
    expr->typeCheck();
}

void ArrayDefAssignStmt::typeCheck()
{
    // Todo
    id->typeCheck();
    aname.push_back(id->getSymPtr()->getName());
    aname.back();
    arraydef[aname.back()]=0;
    bracketList->typeCheck();
    id->getSymPtr()->setType(new ArrayType(TypeSystem::intType,arraydef[aname.back()]));
    initValList->typeCheck();
    aname.pop_back();
}

void ArrayDefStmt::typeCheck()
{
    // Todo
    id->typeCheck();
    aname.push_back(id->getSymPtr()->getName());
    arraydef[aname.back()]=0;
    bracketList->typeCheck();
    id->getSymPtr()->setType(new ArrayType(TypeSystem::intType,arraydef[aname.back()]));
    // fprintf(stderr,"%s\n",id->getSymPtr()->getType()->toStr().c_str());
    aname.pop_back();
}

void DeclStmt::typeCheck()
{
    // Todo
    defList->typeCheck();
}

void FunctionDef::typeCheck()
{
    // Todo
    
    FunctionType* type = (FunctionType*)this->se->getType();
    // fprintf(stderr, "returntype%s\n",type->getRetType()->toStr().c_str());
    functype.push_back(type->getRetType());
    getret.push_back(false);
    if(type->getRetType()==TypeSystem::voidType){
        getret.back()=true;
    }
    fname .push_back( se->getName());
    funcdeftimes = function[fname.back()].size();
    std::vector<Type*> v,p;
    function[fname.back()].push_back(v);
    function[fname.back()][funcdeftimes].push_back(type->getRetType());
    tempOp.clear();
    if(param!=nullptr){
        param->typeCheck();
    }
    for(int i=0;i<funcdeftimes;i++){
        bool redef=false;
        int size = function[fname.back()][funcdeftimes].size();
        if((int)function[fname.back()][i].size()==size){
            if(size==1){
                redef=true;
            }
            for(int j=1;j<(int)function[fname.back()][funcdeftimes].size();j++){
                redef=true;
                if(function[fname.back()][i][j]!=function[fname.back()][funcdeftimes][j]){
                    redef=false;
                    break;
                }
            }
        }
        if(redef){
            fprintf(stderr, "function redefined\n");
            exit(EXIT_FAILURE);
        }
    }
    for(int i=1;i<(int)function[fname.back()][funcdeftimes].size();i++){
        p.push_back(function[fname.back()][funcdeftimes][i]);
    }
    // IdentifierSymbolEntry* temp = (IdentifierSymbolEntry*)se;
    // int scope = temp->getScope()+1;
    
    // for(int i=0;i<(int)p.size();i++){
    //     // fprintf(stderr,"id: %s,type: %s ",FparamId[i].c_str(),p[i]->toStr().c_str());
    //     SymbolEntry* se = new IdentifierSymbolEntry(p[i],FparamId[i],scope);
    //     tempOp.push_back(new Operand(se));
    // }
    setOperand(tempOp);
    tempOp.clear();
    tempOp=getOperand();
    this->se->setType(new FunctionType(type->getRetType(),p));
    stmt->typeCheck();
    if(!getret.back()){
        fprintf(stderr,"miss return stmt\n");
        exit(EXIT_FAILURE);
    }
    
    functype.pop_back();
    getret.pop_back();
    fname.pop_back();
}

void FuncFParam::typeCheck()
{
    // Todo
    
    id->typeCheck();
    // fprintf(stderr, "param %s,%s\n",id->getSymPtr()->getName().c_str(),id->getSymPtr()->getType()->toStr().c_str());
    // fprintf(stderr, "exp\n");
    if(arraytemp>0){
        id->getSymPtr()->setType(new ArrayType(TypeSystem::intType,arraytemp));
    }
    function[fname.back()][funcdeftimes].push_back(id->getSymPtr()->getType());
    tempOp.push_back(new Operand(new IdentifierSymbolEntry(id->getSymPtr()->getType(),id->getSymPtr()->getName(),1)));
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    se->setAddr(tempOp.back());
}

void FuncFParams ::typeCheck()
{
    // Todo
    funcFParams->typeCheck();
    funcFParam->typeCheck();
}

void AssignStmt::typeCheck()
{
    // Todo
    lval->typeCheck();
    expr->typeCheck();
    Type* type1,* type2;
    type1 = lval->getSymPtr()->getType();
    type2 = expr->getSymPtr()->getType();
    if(type1->isFunc()){
        // FuncCallExpr* expr = (FuncCallExpr*) expr1;
        // type1 = expr->getret()->getRetType();
        FunctionType* type = (FunctionType*)type1;
        type1 = type->getRetType();
    }
    if(type2->isFunc()){
        // FuncCallExpr* expr = (FuncCallExpr*) expr2;
        // type2 = expr->getret()->getRetType();
        FunctionType* type = (FunctionType*)type2;
        type2 = type->getRetType();
        // fprintf(stderr,"type2: %s\n",type2->toStr().c_str());
    }
    
    if(type1->isArray()){
        Id* expr = (Id*) lval;
        ArrayType* tempt = (ArrayType *)expr->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        // fprintf(stderr,"temp: %i , dimension: %i\n",temp,di);
        if(temp==di){
            type1 = TypeSystem::intType;
        }else if(temp<di){
            type1 = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    if(type2->isArray()){
        Id* expr1 = (Id*) expr;
        ArrayType* tempt = (ArrayType *)expr1->getSymPtr()->getType();
        int temp = arraytemp;
        int di = tempt->getDimen();
        if(temp==di){
            type2 = TypeSystem::intType;
        }else if(temp<di){
            type2 = new ArrayType(TypeSystem::intType,di-temp);
        }
    }
    // fprintf(stderr,"type1 : %s , type2 : %s \n",type1->toStr().c_str(),type2->toStr().c_str());
    if(!(type1->isInt()&&type2->isInt())){
        fprintf(stderr, "type %s cannot be assign by %s  \n",
           type1->toStr().c_str(), type2->toStr().c_str());
        exit(EXIT_FAILURE);
    }
}


void Ast::output()
{
    fprintf(yyout, "program\n");
    if(root != nullptr)
        root->output(4);
}

void BinaryExpr::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "add";
            break;
        case SUB:
            op_str = "sub";
            break;
        case MUL:
            op_str = "mul";
            break;
        case DIV:
            op_str = "div";
            break;
        case MOD:
            op_str = "mod";
            break;
        case AND:
            op_str = "and";
            break;
        case OR:
            op_str = "or";
            break;
        case LESS:
            op_str = "less";
            break;
        case MORE:
            op_str = "more";
            break;
        case LESSEQU:
            op_str = "less equal";
            break;
        case MOREEQU:
            op_str = "more equal";
            break;
        case NOTEQUAL:
            op_str = "not equal";
            break;
        case EQUAL:
            op_str = "equal";
            break;
    }
    // fprintf(yyout, "%*cBinaryExpr\top: %s  type: %s\n", level, ' ', op_str.c_str(),symbolEntry->getType()->toStr().c_str());
    expr1->output(level + 4);
    expr2->output(level + 4);
}

void UnaryExpr::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "ADD";
            break;
        case SUB:
            op_str = "SUB";
            break;
        case NOT:
            op_str = "NOT";
            break;
    }
    fprintf(yyout, "%*cUnaryExpr\top: %s\n", level, ' ', op_str.c_str());
    expr->output(level + 4);
}

void Constant::output(int level)
{
    std::string type, value;
    type = symbolEntry->getType()->toStr();
    value = symbolEntry->toStr();
    fprintf(yyout, "%*cIntegerLiteral\tvalue: %s\ttype: %s\n", level, ' ',
            value.c_str(), type.c_str());
}

void Id::output(int level)
{
    if(symbolEntry!=nullptr){
        std::string name, type;
        int scope;
        name = symbolEntry->toStr();
        type = symbolEntry->getType()->toStr();
        scope = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getScope();
        fprintf(yyout, "%*cId\tname: %s\tscope: %d\ttype: %s\n", level, ' ',
                name.c_str(), scope, type.c_str());
        if(bracketList!=nullptr){
            fprintf(yyout, "%*cArrayIndex\n", level, ' ');
            bracketList->output(level+4);
        }
    }
}

void CompoundStmt::output(int level)
{
    fprintf(yyout, "%*cCompoundStmt\n", level, ' ');
    if(stmt!=nullptr){
        stmt->output(level + 4);
    }
}

void SeqNode::output(int level)
{
    fprintf(yyout, "%*cSequence\n", level, ' ');
    stmt1->output(level + 4);
    stmt2->output(level + 4);
}

void ExprStmt:: output(int level)
{
    fprintf(yyout, "%*cExprStmt\n", level, ' ');
    expr->output(level + 4);
}

void DeclStmt::output(int level)
{
    fprintf(yyout, "%*cDeclStmt\n", level, ' ');
    defList->output(level+4);
}

void DefStmtList::output(int level)
{
    fprintf(yyout, "%*cDeclStmtList\n", level, ' ');
    def1->output(level+4);
    def2->output(level+4);
}

void DefStmt::output(int level)
{
    fprintf(yyout, "%*cDefStmt\n", level, ' ');
    id->output(level+4);
}

void ArrayDefStmt::output(int level)
{
    fprintf(yyout, "%*cArrayDefStmt\n", level, ' ');
    id->output(level+4);
    bracketList->output(level+4);
}

void ArrayDefAssignStmt::output(int level){
    fprintf(yyout, "%*cArrayDefAssignStmt\n", level, ' ');
    id->output(level+4);
    bracketList->output(level+4);
    initValList->output(level+4);
}

void DefAssignStmt::output(int level){
    fprintf(yyout, "%*cDefAssignStmt\n", level, ' ');
    id->output(level+4);
    expr->output(level+4);
}

void BracketList::output(int level){
    fprintf(yyout, "%*cBracketList\n", level, ' ');
    bracket->output(level+4);
    bracketList->output(level+4);
}

void Bracket::output(int level){
    fprintf(yyout, "%*cBracket\n", level, ' ');
    if(expr!=nullptr)
    {
        expr->output(level+4);
    }
    else{
        fprintf(yyout,"%*cEmptyBracket\n", level+4, ' ');
    }
}

void InitValList::output(int level)
{
    fprintf(yyout,"%*cInitValList\n", level, ' ');
    if(initVal!=nullptr && initValList!=nullptr)
    {
        initVal->output(level+4);
        initValList->output(level+4);
    }
}

void InitVal::output(int level)
{
    fprintf(yyout,"%*cInitVal\n", level, ' ');
    expr->output(level+4);
}

void FuncRParam::output(int level)
{
    fprintf(yyout, "%*cFuncRParam\n", level, ' ');
    expr->output(level+4);
}

void FuncRParams::output(int level)
{
    fprintf(yyout, "%*cFuncRParams\n", level, ' ');
    funcRParam->output(level+4);
    funcRParams->output(level+4);
}

void FuncCallExpr::output(int level)
{
    fprintf(yyout, "%*cFuncCallStmt\n", level, ' ');
    id->output(level+4);
    if(funcRParams!=nullptr)
    {
        funcRParams->output(level+4);
    }
}

void FuncFParam::output(int level)
{
    fprintf(yyout, "%*cFuncFParam\n", level, ' ');
    id->output(level+4);
}

void FuncFParams::output(int level)
{
    fprintf(yyout, "%*cFuncFParams\n", level, ' ');
    funcFParams->output(level+4);
    funcFParam->output(level+4);
}

void IfStmt::output(int level)
{
    fprintf(yyout, "%*cIfStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
}

void WhileStmt::output(int level)
{
    fprintf(yyout, "%*cWhileStmt\n", level, ' ');
    cond->output(level + 4);
    whileStmt->output(level + 4);
}

void IfElseStmt::output(int level)
{
    fprintf(yyout, "%*cIfElseStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
    fprintf(yyout, "%*cElseStmt\n", level, ' ');
    elseStmt->output(level + 4);
}

void ReturnStmt_noExp::output(int level)
{
    fprintf(yyout, "%*cReturnStmt\n", level, ' ');
}

void ReturnStmt::output(int level)
{
    fprintf(yyout, "%*cReturnStmt\n", level, ' ');
    retValue->output(level + 4);
}

void ContinueStmt::output(int level)
{
    fprintf(yyout, "%*cContinueStmt\n", level, ' ');
}

void BreakStmt::output(int level)
{
    fprintf(yyout, "%*cBreakStmt\n", level, ' ');
}

void EmptyStmt::output(int level)
{
    fprintf(yyout, "%*cEmptyStmt\n", level, ' ');
}


void AssignStmt::output(int level)
{
    fprintf(yyout, "%*cAssignStmt\n", level, ' ');
    lval->output(level + 4);
    expr->output(level + 4);
}

void FunctionDef::output(int level)
{
    std::string name, type;
    name = se->toStr();
    type = se->getType()->toStr();
    FunctionType* ft = (FunctionType*)se->getType();
    std::vector<Type*> v = ft->getParams();
    fprintf(yyout, "%*cFunctionDefine function name: %s, type: %s, params:{", level, ' ', 
            name.c_str(), type.c_str());
    for(int i=0;i<(int)v.size();i++){
        fprintf(yyout,"%s ",v[i]->toStr().c_str());
    }
    fprintf(yyout,"}\n");
    if(param!=nullptr){
        param->output(level+4);
    }
    stmt->output(level + 4);
}
